// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: recipes_ingredients.sql

package database

import (
	"context"

	"github.com/google/uuid"
)

const createRecipeIngredient = `-- name: CreateRecipeIngredient :one
INSERT INTO recipes_ingredients (recipe_id, ingredient_id, quantity, created_at, updated_at)
VALUES (
    $1, $2, $3, NOW(), NOW()
)
RETURNING recipe_id, ingredient_id, quantity, created_at, updated_at
`

type CreateRecipeIngredientParams struct {
	RecipeID     uuid.UUID
	IngredientID uuid.UUID
	Quantity     string
}

func (q *Queries) CreateRecipeIngredient(ctx context.Context, arg CreateRecipeIngredientParams) (RecipesIngredient, error) {
	row := q.db.QueryRowContext(ctx, createRecipeIngredient, arg.RecipeID, arg.IngredientID, arg.Quantity)
	var i RecipesIngredient
	err := row.Scan(
		&i.RecipeID,
		&i.IngredientID,
		&i.Quantity,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRecipeIngredient = `-- name: DeleteRecipeIngredient :exec
DELETE FROM
    recipes_ingredients
WHERE
    recipe_id = $1 AND ingredient_id = $2
`

type DeleteRecipeIngredientParams struct {
	RecipeID     uuid.UUID
	IngredientID uuid.UUID
}

func (q *Queries) DeleteRecipeIngredient(ctx context.Context, arg DeleteRecipeIngredientParams) error {
	_, err := q.db.ExecContext(ctx, deleteRecipeIngredient, arg.RecipeID, arg.IngredientID)
	return err
}

const getAllRecipeIngredients = `-- name: GetAllRecipeIngredients :many
SELECT recipe_id, ingredient_id, quantity, created_at, updated_at FROM recipes_ingredients
`

func (q *Queries) GetAllRecipeIngredients(ctx context.Context) ([]RecipesIngredient, error) {
	rows, err := q.db.QueryContext(ctx, getAllRecipeIngredients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []RecipesIngredient
	for rows.Next() {
		var i RecipesIngredient
		if err := rows.Scan(
			&i.RecipeID,
			&i.IngredientID,
			&i.Quantity,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getIngredientsByRecipe = `-- name: GetIngredientsByRecipe :many
SELECT
    i.name AS ingredient_name,
    i.unit,
    ri.quantity
FROM
    ingredients i
JOIN
    recipes_ingredients ri ON i.id = ri.ingredient_id
WHERE
    ri.recipe_id = $1
`

type GetIngredientsByRecipeRow struct {
	IngredientName string
	Unit           string
	Quantity       string
}

func (q *Queries) GetIngredientsByRecipe(ctx context.Context, recipeID uuid.UUID) ([]GetIngredientsByRecipeRow, error) {
	rows, err := q.db.QueryContext(ctx, getIngredientsByRecipe, recipeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetIngredientsByRecipeRow
	for rows.Next() {
		var i GetIngredientsByRecipeRow
		if err := rows.Scan(&i.IngredientName, &i.Unit, &i.Quantity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipesByIngredient = `-- name: GetRecipesByIngredient :many
SELECT
    r.name AS recipe_name,
    r.description
FROM
    recipes r
JOIN
    recipes_ingredients ri ON r.id = ri.receipe_id
WHERE
    ri.ingredient_id = $1
`

type GetRecipesByIngredientRow struct {
	RecipeName  string
	Description string
}

func (q *Queries) GetRecipesByIngredient(ctx context.Context, ingredientID uuid.UUID) ([]GetRecipesByIngredientRow, error) {
	rows, err := q.db.QueryContext(ctx, getRecipesByIngredient, ingredientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRecipesByIngredientRow
	for rows.Next() {
		var i GetRecipesByIngredientRow
		if err := rows.Scan(&i.RecipeName, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
